<?php
declare( strict_types = 1 );

namespace Wikimedia\Parsoid\NodeData;

use stdClass;
use Wikimedia\JsonCodec\Hint;
use Wikimedia\JsonCodec\JsonCodec;
use Wikimedia\JsonCodec\JsonCodecable;
use Wikimedia\JsonCodec\JsonCodecableTrait;
use Wikimedia\Parsoid\Tokens\SourceRange;

/**
 * Editing data for a DOM node.  Managed by DOMDataUtils::get/setDataMw().
 *
 * To reduce memory usage, most of the properties need to be dynamic, but
 * we use the property declarations below to allow type checking.
 *
 * @property list<string|DataMwPart> $parts
 * @property string $name
 * @property string $extPrefix
 * @property string $extSuffix
 * @property list<array{stdClass,stdClass}> $attribs
 * @property string $src
 * @property string $caption
 * @property string $thumb
 * @property bool $autoGenerated
 * @property list<stdClass> $errors
 * @property stdClass $body
 * @property mixed $html
 * @property float $scale
 * @property string $starttime
 * @property string $endtime
 * @property string $thumbtime
 * @property string $page
 * == Annotations ==
 * @property string $rangeId
 * @property SourceRange $wtOffsets
 * @property bool $extendedRange
 * @property stdClass $attrs
 */
#[\AllowDynamicProperties]
class DataMw implements JsonCodecable {
	use JsonCodecableTrait;

	public function __construct( array $initialVals = [] ) {
		foreach ( $initialVals as $k => $v ) {
			// @phan-suppress-next-line PhanNoopSwitchCases
			switch ( $k ) {
				// Add cases here for components which should be instantiated
				// as proper classes.
				default:
					$this->$k = $v;
					break;
			}
		}
	}

	/** Returns true iff there are no dynamic properties of this object. */
	public function isEmpty(): bool {
		return ( (array)$this ) === [];
	}

	/**
	 * Deeply clone this object
	 *
	 * @return DataMw
	 */
	public function clone(): self {
		$codec = new JsonCodec;
		return $codec->newFromJsonArray( $codec->toJsonArray( $this ) );
	}

	/** @inheritDoc */
	public static function jsonClassHintFor( string $keyname ) {
		static $hints = null;
		if ( $hints === null ) {
			$hints = [
				'attribs' => Hint::build( stdClass::class, Hint::LIST, Hint::LIST ),
				'attrs' => Hint::build( stdClass::class, Hint::ALLOW_OBJECT ),
				'body' => Hint::build( stdClass::class, Hint::ALLOW_OBJECT ),
				'wtOffsets' => Hint::build( SourceRange::class, Hint::USE_SQUARE ),
				'parts' => Hint::build( DataMwPart::class, Hint::LIST ),
				// T367141
				'errors' => Hint::build( stdClass::class, Hint::LIST ),
			];
		}
		return $hints[$keyname] ?? null;
	}

	/** @inheritDoc */
	public function toJsonArray(): array {
		$result = (array)$this;
		// T367141: Third party clients (eg Cite) create arrays instead of
		// error objects.  We should convert them to proper DataMwError
		// objects once those exist.
		if ( isset( $result['errors'] ) ) {
			$result['errors'] = array_map(
				fn ( $e ) => is_array( $e ) ? (object)$e : $e,
				$result['errors']
			);
		}
		return $result;
	}

	/** @inheritDoc */
	public static function newFromJsonArray( array $json ): DataMw {
		return new DataMw( $json );
	}
}
